<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Bin Packing Visualization</title>
    <style>
        .bin-container { display: flex; flex-wrap: wrap; gap: 20px; margin-top: 20px; }
        canvas { border: 1px solid black; }
        table { border-collapse: collapse; margin-top: 10px; }
        th, td { border: 1px solid #ccc; padding: 5px; }
        input { width: 80px; }
        .quantity-input { width: 60px; }
        .section { margin: 20px 0; padding: 10px; border: 1px solid #ccc; }
        .bin-card { border: 1px solid #ddd; border-radius: 5px; padding: 15px; margin-bottom: 15px; background-color: #f9f9f9; }
        .remainder-material { background-color: #e8f5e8; border-color: #4caf50; border-width: 2px; }
        .new-material { background-color: #e3f2fd; border-color: #2196f3; }
        .bin-title { margin: 0 0 10px 0; color: #333; }
        .bin-subtitle { margin: 0 0 10px 0; font-size: 14px; color: #666; }
        .new-material-settings { background-color: #fff3e0; border: 1px solid #ff9800; padding: 10px; margin: 10px 0; }
    </style>
</head>
<body>
<h1>Cutting Optimizer Visualization</h1>

<!-- 添加项目 -->
<div class="section">
    <h3>添加切割项目</h3>
    <input type="text" id="label" placeholder="标签">
    <input type="number" id="width" placeholder="宽(cm)" step="0.1" min="0.1">
    <input type="number" id="height" placeholder="高(cm)" step="0.1" min="0.1">
    <input type="number" id="quantity" placeholder="数量" class="quantity-input" value="1" min="1">
    <button onclick="addItem()">添加项目</button>
</div>

<!-- 添加剩余材料 -->
<div class="section">
    <h3>添加剩余材料</h3>
    <input type="text" id="materialName" placeholder="材料名称">
    <input type="number" id="materialWidth" placeholder="宽(cm)" step="0.1" min="0.1">
    <input type="number" id="materialHeight" placeholder="高(cm)" step="0.1" min="0.1">
    <input type="number" id="materialCount" placeholder="数量" class="quantity-input" value="1" min="1">
    <button onclick="addMaterial()">添加材料</button>
</div>

<!-- 操作按钮 -->
<div>
    <button onclick="runOptimization()">开始优化</button>
    <button onclick="clearAll()">清空所有</button>
</div>

<!-- 项目列表 -->
<h3>切割项目</h3>
<table id="itemTable">
    <thead>
    <tr>
        <th>Label</th>
        <th>Width (cm)</th>
        <th>Height (cm)</th>
        <th>数量</th>
        <th>操作</th>
    </tr>
    </thead>
    <tbody></tbody>
</table>

<!-- 剩余材料列表 -->
<h3>剩余材料</h3>
<table id="materialTable">
    <thead>
    <tr>
        <th>名称</th>
        <th>Width (cm)</th>
        <th>Height (cm)</th>
        <th>数量</th>
        <th>操作</th>
    </tr>
    </thead>
    <tbody></tbody>
</table>

<!-- 统计信息 -->
<div id="stats"></div>

<!-- 结果画布 -->
<div id="bins" class="bin-container"></div>

<script>
    let items = [];
    let materials = [];


    function addItem() {
        const label = document.getElementById('label').value.trim();
        const width = parseFloat(document.getElementById('width').value);
        const height = parseFloat(document.getElementById('height').value);
        const quantity = parseInt(document.getElementById('quantity').value);

        if (!label || isNaN(width) || isNaN(height) || isNaN(quantity) ||
            width <= 0 || height <= 0 || quantity <= 0) {
            alert("请输入有效的项目参数！");
            return;
        }

        // 检查是否已存在相同标签的项目
        const existingIndex = items.findIndex(item => item.label === label);
        if (existingIndex !== -1) {
            items[existingIndex].quantity = quantity;
        } else {
            items.push({label, width, height, quantity});
        }

        renderItemTable();
        updateStats();
        clearItemInputs();
    }

    function addMaterial() {
        const name = document.getElementById('materialName').value.trim();
        const width = parseFloat(document.getElementById('materialWidth').value);
        const height = parseFloat(document.getElementById('materialHeight').value);
        const count = parseInt(document.getElementById('materialCount').value);

        if (!name || isNaN(width) || isNaN(height) || isNaN(count) ||
            width <= 0 || height <= 0 || count <= 0) {
            alert("请输入有效的材料参数！");
            return;
        }

        materials.push({name, width, height, count});
        renderMaterialTable();
        updateStats();
        clearMaterialInputs();
    }

    function removeItem(index) {
        items.splice(index, 1);
        renderItemTable();
        updateStats();
    }

    function removeMaterial(index) {
        materials.splice(index, 1);
        renderMaterialTable();
        updateStats();
    }

    function clearAll() {
        items = [];
        materials = [];
        renderItemTable();
        renderMaterialTable();
        updateStats();
        document.getElementById('bins').innerHTML = '';
    }

    function clearItemInputs() {
        document.getElementById('label').value = '';
        document.getElementById('width').value = '';
        document.getElementById('height').value = '';
        document.getElementById('quantity').value = '1';
        document.getElementById('label').focus();
    }

    function clearMaterialInputs() {
        document.getElementById('materialName').value = '';
        document.getElementById('materialWidth').value = '';
        document.getElementById('materialHeight').value = '';
        document.getElementById('materialCount').value = '1';
        document.getElementById('materialName').focus();
    }

    function renderItemTable() {
        const tbody = document.querySelector('#itemTable tbody');
        tbody.innerHTML = '';
        items.forEach((item, index) => {
            const tr = document.createElement('tr');
            tr.innerHTML = `
                <td>${item.label}</td>
                <td>${item.width.toFixed(1)}</td>
                <td>${item.height.toFixed(1)}</td>
                <td>${item.quantity}</td>
                <td><button onclick="removeItem(${index})">删除</button></td>
            `;
            tbody.appendChild(tr);
        });
    }

    function renderMaterialTable() {
        const tbody = document.querySelector('#materialTable tbody');
        tbody.innerHTML = '';
        materials.forEach((material, index) => {
            const tr = document.createElement('tr');
            tr.innerHTML = `
                <td>${material.name}</td>
                <td>${material.width.toFixed(1)}</td>
                <td>${material.height.toFixed(1)}</td>
                <td>${material.count}</td>
                <td><button onclick="removeMaterial(${index})">删除</button></td>
            `;
            tbody.appendChild(tr);
        });
    }

    function updateStats() {
        const totalItems = items.reduce((sum, item) => sum + item.quantity, 0);
        const totalMaterials = materials.reduce((sum, material) => sum + material.count, 0);
        const totalItemArea = items.reduce((sum, item) => sum + (item.width * item.height * item.quantity), 0);

        document.getElementById('stats').innerHTML =
            `<p>总项目数: ${totalItems} (面积: ${totalItemArea.toFixed(1)} cm²), 剩余材料: ${totalMaterials} 种</p>`;
    }

    async function runOptimization() {
        if (items.length === 0) {
            alert("请先添加至少一个切割项目！");
            return;
        }

        // 展开数量：将每个项目根据数量生成多个实例
        const expandedItems = [];
        items.forEach(item => {
            for (let i = 0; i < item.quantity; i++) {
                expandedItems.push({
                    label: `${item.label}_${i + 1}`,
                    width: item.width,
                    height: item.height
                });
            }
        });

        // 准备材料数据（保持厘米单位发送给后端）
        const materialData = materials.map(material => ({
            name: material.name,
            width: material.width / 100, // 转换为米
            height: material.height / 100, // 转换为米
            availableCount: material.count
        }));


        // 合并现有材料和新板材
        const allMaterialsForAPI = [...materialData];

        console.log("发送到API的数据:", {
            items: expandedItems.map(i => ({
                label: i.label,
                width: i.width / 100, // 转换为米
                height: i.height / 100 // 转换为米
            })),
            materials: allMaterialsForAPI  // 包含了新板材设置！
        });

        // API 接口是米，这里厘米 → 米
        const payload = {
            items: expandedItems.map(i => ({
                label: i.label,
                width: +(i.width / 100).toFixed(4),
                height: +(i.height / 100).toFixed(4)
            })),
            materials: allMaterialsForAPI  // 真正传递包含新板材的所有材料！
        };

        try {
            const response = await fetch("/api/optimize-with-materials", {
                method: "POST",
                headers: {"Content-Type": "application/json"},
                body: JSON.stringify(payload)
            });

            if (!response.ok) {
                throw new Error(response.statusText);
            }

            const results = await response.json();
            console.log("API返回结果:", results);

            // 计算总项目数（用于显示）
            const totalOriginalItems = items.reduce((sum, item) => sum + item.quantity, 0);
            drawBins(results, totalOriginalItems);
        } catch (error) {
            alert("API 调用失败: " + error.message);
        }
    }

    function drawBins(results, totalItems) {
        const container = document.getElementById('bins');
        container.innerHTML = "";

        // 收集用户定义的材料名称，用于判断是否为旧材料
        const userMaterialNames = new Set(materials.map(m => m.name));

        // 找到所有材料中的最大尺寸，用于统一缩放
        let maxMaterialWidth = 0;
        let maxMaterialHeight = 0;
        results.forEach(bin => {
            if (bin.materialWidth > maxMaterialWidth) maxMaterialWidth = bin.materialWidth;
            if (bin.materialHeight > maxMaterialHeight) maxMaterialHeight = bin.materialHeight;
        });

        // 计算缩放比例（基于最大材料尺寸）
        const maxCanvasSize = 400;
        const scale = Math.min(
            maxCanvasSize / (maxMaterialWidth * 100),
            maxCanvasSize / (maxMaterialHeight * 100)
        ) * 100;

        // 显示总体统计
        const totalMaterialsUsed = results.length;
        const summary = document.createElement('div');
        summary.innerHTML = `
            <h3>优化结果: 使用 ${totalMaterialsUsed} 块材料, 放置 ${totalItems} 个项目</h3>
        `;
        container.appendChild(summary);

        results.forEach((bin, index) => {
            const binCard = document.createElement('div');
            binCard.className = 'bin-card';

            // 判断是否为用户提供的旧材料
            let isRemainderMaterial = false;
            if (bin.materialType) {
                // 检查是否是用户定义的材料名称
                isRemainderMaterial = userMaterialNames.has(bin.materialType) ||
                    Array.from(userMaterialNames).some(name => bin.materialType.startsWith(name + '_'));
                // 特殊处理：如果是新板材则不是旧材料
                if (bin.materialType.includes('新')) {
                    isRemainderMaterial = false;
                }
            }

            if (isRemainderMaterial) {
                binCard.classList.add('remainder-material');
            } else {
                binCard.classList.add('new-material');
            }

            // 使用厘米显示尺寸
            const displayWidth = (bin.materialWidth * 100).toFixed(1);
            const displayHeight = (bin.materialHeight * 100).toFixed(1);

            const title = document.createElement('h3');
            title.className = 'bin-title';
            title.textContent = bin.materialType || '材料';

            const subtitle = document.createElement('p');
            subtitle.className = 'bin-subtitle';
            subtitle.innerHTML = `
                ID: ${bin.binId} |
                尺寸: ${displayWidth}×${displayHeight}cm |
                利用率: ${bin.utilization.toFixed(1)}%
                ${isRemainderMaterial ? ' ♻️ 剩余材料' : ' 🆕 新材料'}
            `;

            binCard.appendChild(title);
            binCard.appendChild(subtitle);

            const canvas = document.createElement('canvas');
            // 使用实际材料尺寸计算画布大小
            const binWidthCm = bin.materialWidth * 100;
            const binHeightCm = bin.materialHeight * 100;
            const canvasWidth = Math.max(200, binWidthCm * scale / 100);
            const canvasHeight = Math.max(200, binHeightCm * scale / 100);
            canvas.width = canvasWidth;
            canvas.height = canvasHeight;
            const ctx = canvas.getContext('2d');

            // 绘制材料背景
            ctx.fillStyle = isRemainderMaterial ? '#e8f5e8' : '#e3f2fd';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // 绘制材料边界（使用实际尺寸）
            const binWidthPx = binWidthCm * scale / 100;
            const binHeightPx = binHeightCm * scale / 100;

            ctx.strokeStyle = '#333';
            ctx.lineWidth = 2;
            ctx.strokeRect(0, 0, binWidthPx, binHeightPx);

            // 绘制网格线（每10厘米）
            ctx.strokeStyle = '#bbb';
            ctx.lineWidth = 1;
            const gridSpacingCm = 10;

            // 垂直网格线
            for (let i = 0; i <= Math.ceil(binWidthCm / gridSpacingCm); i++) {
                const x = i * gridSpacingCm * scale / 100;
                if (x <= binWidthPx) {
                    ctx.beginPath();
                    ctx.moveTo(x, 0);
                    ctx.lineTo(x, binHeightPx);
                    ctx.stroke();
                }
            }

            // 水平网格线
            for (let i = 0; i <= Math.ceil(binHeightCm / gridSpacingCm); i++) {
                const y = i * gridSpacingCm * scale / 100;
                if (y <= binHeightPx) {
                    ctx.beginPath();
                    ctx.moveTo(0, y);
                    ctx.lineTo(binWidthPx, y);
                    ctx.stroke();
                }
            }

            // 绘制每个piece（使用厘米单位）
            bin.pieces.forEach(piece => {
                const hue = Math.floor(Math.random() * 360);
                const color = `hsl(${hue}, 70%, 80%)`;

                // 使用厘米单位绘制
                const x = Math.round((piece.x * 100) * scale / 100);
                const y = Math.round((piece.y * 100) * scale / 100);
                const w = Math.round((piece.w * 100) * scale / 100);
                const h = Math.round((piece.h * 100) * scale / 100);

                // 绘制填充
                ctx.fillStyle = color;
                ctx.fillRect(x, y, w, h);

                // 绘制边框
                ctx.strokeStyle = '#333';
                ctx.lineWidth = 1;
                ctx.strokeRect(x, y, w, h);

                // 绘制标签背景
                ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
                const labelWidth = Math.min(w - 4, 120);
                ctx.fillRect(x + 2, y + 2, labelWidth, 36);

                // 绘制标签文字
                ctx.fillStyle = 'white';
                ctx.font = '12px Arial';
                ctx.fillText(piece.label, x + 6, y + 16);

                // 显示尺寸（使用厘米）
                ctx.fillStyle = 'white';
                ctx.font = '11px Arial';
                const sizeText = `${(piece.w * 100).toFixed(1)}×${(piece.h * 100).toFixed(1)}cm`;
                ctx.fillText(sizeText, x + 6, y + 30);
            });

            binCard.appendChild(canvas);
            container.appendChild(binCard);
        });
    }

    // 回车键添加项目
    document.addEventListener('keypress', function(e) {
        if (e.key === 'Enter') {
            if (document.activeElement.id === 'label' ||
                document.activeElement.id === 'width' ||
                document.activeElement.id === 'height' ||
                document.activeElement.id === 'quantity') {
                addItem();
            } else if (document.activeElement.id === 'materialName' ||
                document.activeElement.id === 'materialWidth' ||
                document.activeElement.id === 'materialHeight' ||
                document.activeElement.id === 'materialCount') {
                addMaterial();
            }
        }
    });

    // 页面加载时聚焦到第一个输入框
    window.addEventListener('load', function() {
        document.getElementById('label').focus();
    });
</script>
</body>
</html>